<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/CMakeLists.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CMakeLists.txt" />
              <option name="originalContent" value="cmake_minimum_required(VERSION 3.20)&#10;project(mite VERSION 0.1.0 LANGUAGES CXX)&#10;&#10;set(CMAKE_CXX_STANDARD 23)&#10;#set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;#set(CMAKE_CXX_EXTENSIONS OFF)&#10;&#10;# Include FetchContent module&#10;include(FetchContent)&#10;&#10;# Fetch raylib&#10;FetchContent_Declare(&#10;    raylib&#10;    GIT_REPOSITORY https://github.com/raysan5/raylib.git&#10;    GIT_TAG 5.0&#10;)&#10;&#10;# Set raylib configuration options&#10;set(BUILD_EXAMPLES OFF CACHE BOOL &quot;&quot; FORCE) # don't build the supplied examples&#10;set(BUILD_GAMES OFF CACHE BOOL &quot;&quot; FORCE)    # don't build the supplied example games&#10;&#10;# Make raylib available&#10;FetchContent_MakeAvailable(raylib)&#10;&#10;add_executable(mite)&#10;&#10;target_sources(mite PRIVATE&#10;    src/main.cpp&#10;        PUBLIC&#10;        FILE_SET CXX_MODULES&#10;        FILES&#10;        include/modules/mite/mite.ixx&#10;        include/modules/mite/flat/point.ixx&#10;        include/modules/mite/flat/size.ixx&#10;        include/modules/mite/flat/mod.ixx&#10;        include/modules/mite/square.ixx&#10;        include/modules/mite/rect.ixx&#10;)&#10;&#10;# Link raylib to the mite target&#10;target_link_libraries(mite raylib)&#10;&#10;# Platform-specific configurations&#10;if(WIN32)&#10;    target_link_libraries(mite winmm)&#10;elseif(APPLE)&#10;    target_link_libraries(mite &quot;-framework IOKit&quot; &quot;-framework Cocoa&quot; &quot;-framework OpenGL&quot;)&#10;elseif(UNIX)&#10;    target_link_libraries(mite m dl pthread GL X11)&#10;endif()&#10;" />
              <option name="updatedContent" value="cmake_minimum_required(VERSION 3.20)&#10;project(mite VERSION 0.1.0 LANGUAGES CXX)&#10;&#10;set(CMAKE_CXX_STANDARD 23)&#10;#set(CMAKE_CXX_STANDARD_REQUIRED ON)&#10;#set(CMAKE_CXX_EXTENSIONS OFF)&#10;&#10;# Include FetchContent module&#10;include(FetchContent)&#10;&#10;# Fetch raylib&#10;FetchContent_Declare(&#10;    raylib&#10;    GIT_REPOSITORY https://github.com/raysan5/raylib.git&#10;    GIT_TAG 5.0&#10;)&#10;&#10;# Fetch Google Test&#10;FetchContent_Declare(&#10;    googletest&#10;    GIT_REPOSITORY https://github.com/google/googletest.git&#10;    GIT_TAG v1.14.0&#10;)&#10;&#10;# Set raylib configuration options&#10;set(BUILD_EXAMPLES OFF CACHE BOOL &quot;&quot; FORCE) # don't build the supplied examples&#10;set(BUILD_GAMES OFF CACHE BOOL &quot;&quot; FORCE)    # don't build the supplied example games&#10;&#10;# Set Google Test configuration options&#10;set(gtest_force_shared_crt ON CACHE BOOL &quot;&quot; FORCE)&#10;&#10;# Make both libraries available&#10;FetchContent_MakeAvailable(raylib googletest)&#10;&#10;add_executable(mite)&#10;&#10;target_sources(mite PRIVATE&#10;    src/main.cpp&#10;        PUBLIC&#10;        FILE_SET CXX_MODULES&#10;        FILES&#10;        include/modules/mite/mite.ixx&#10;        include/modules/mite/flat/point.ixx&#10;        include/modules/mite/flat/size.ixx&#10;        include/modules/mite/flat/mod.ixx&#10;        include/modules/mite/square.ixx&#10;        include/modules/mite/rect.ixx&#10;)&#10;&#10;# Link raylib to the mite target&#10;target_link_libraries(mite raylib)&#10;&#10;# Enable testing&#10;enable_testing()&#10;&#10;# Create a test executable (optional - you can add test files later)&#10;# add_executable(mite_tests&#10;#     tests/test_point.cpp&#10;#     tests/test_size.cpp&#10;#     tests/test_square.cpp&#10;#     tests/test_rect.cpp&#10;# )&#10;#&#10;# target_sources(mite_tests&#10;#     PUBLIC&#10;#     FILE_SET CXX_MODULES&#10;#     FILES&#10;#     include/modules/mite/flat/point.ixx&#10;#     include/modules/mite/flat/size.ixx&#10;#     include/modules/mite/square.ixx&#10;#     include/modules/mite/rect.ixx&#10;# )&#10;#&#10;# target_link_libraries(mite_tests&#10;#     gtest_main&#10;#     gmock_main&#10;# )&#10;#&#10;# include(GoogleTest)&#10;# gtest_discover_tests(mite_tests)&#10;&#10;# Platform-specific configurations&#10;if(WIN32)&#10;    target_link_libraries(mite winmm)&#10;elseif(APPLE)&#10;    target_link_libraries(mite &quot;-framework IOKit&quot; &quot;-framework Cocoa&quot; &quot;-framework OpenGL&quot;)&#10;elseif(UNIX)&#10;    target_link_libraries(mite m dl pthread GL X11)&#10;endif()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/include/modules/mite/flat/point.ixx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/modules/mite/flat/point.ixx" />
              <option name="originalContent" value="module;&#10;#include &lt;type_traits&gt;&#10;&#10;export module mite.point;&#10;&#10;export namespace mite {&#10;   namespace flat {&#10;       /**&#10;     * @brief A template class representing a 2D point with arithmetic operations.&#10;     * @tparam T The type of the coordinates, must be an arithmetic type.&#10;     */&#10;       template &lt;typename T&gt;&#10;       struct Point {&#10;           static_assert(std::is_arithmetic_v&lt;T&gt;, &quot;Point must be of an arithmetic type&quot;);&#10;&#10;       protected:&#10;           T x_; ///&lt; The x-coordinate of the point.&#10;           T y_; ///&lt; The y-coordinate of the point.&#10;&#10;       public:&#10;           /**&#10;            * @brief Constructs a Point with given x and y coordinates.&#10;            * @param x The x-coordinate (default is 0).&#10;            * @param y The y-coordinate (default is 0).&#10;            */&#10;           explicit Point(T x = 0, T y = 0) : x_(x), y_(y) {&#10;           }&#10;&#10;           /**&#10;            * @brief Adds two points.&#10;            * @param other The other point to add.&#10;            * @return A new Point that is the sum of this and the other point.&#10;            */&#10;           Point operator+(const Point&amp; other) const {&#10;               return Point(x_ + other.x_, y_ + other.y_);&#10;           }&#10;&#10;           /**&#10;            * @brief Adds another point to this point.&#10;            * @param other The other point to add.&#10;            * @return A reference to this point after addition.&#10;            */&#10;           Point&amp; operator+=(const Point&amp; other) {&#10;               x_ += other.x_;&#10;               y_ += other.y_;&#10;               return *this;&#10;           }&#10;&#10;           /**&#10;            * @brief Subtracts another point from this point.&#10;            * @param other The other point to subtract.&#10;            * @return A new Point that is the difference of this and the other point.&#10;            */&#10;           Point operator-(const Point&amp; other) const {&#10;               return Point(x_ - other.x_, y_ - other.y_);&#10;           }&#10;&#10;           /**&#10;            * @brief Subtracts another point from this point.&#10;            * @param other The other point to subtract.&#10;            * @return A reference to this point after subtraction.&#10;            */&#10;           Point&amp; operator-=(const Point&amp; other) {&#10;               x_ -= other.x_;&#10;               y_ -= other.y_;&#10;               return *this;&#10;           }&#10;&#10;           /**&#10;            * @brief Multiplies this point by a scalar.&#10;            * @param scalar The scalar value to multiply by.&#10;            * @return A new Point that is the result of the multiplication.&#10;            */&#10;           Point operator*(T scalar) const {&#10;               return Point(x_ * scalar, y_ * scalar);&#10;           }&#10;&#10;           /**&#10;            * @brief Divides this point by a scalar.&#10;            * @param scalar The scalar value to divide by.&#10;            * @return A new Point that is the result of the division.&#10;            */&#10;           Point operator/(T scalar) const {&#10;               return Point(x_ / scalar, y_ / scalar);&#10;           }&#10;&#10;           /**&#10;            * @brief Checks if two points are equal.&#10;            * @param other The other point to compare.&#10;            * @return True if the points are equal, false otherwise.&#10;            */&#10;           bool operator==(const Point&amp; other) const {&#10;               return x_ == other.x_ &amp;&amp; y_ == other.y_;&#10;           }&#10;&#10;           /**&#10;            * @brief Checks if two points are not equal.&#10;            * @param other The other point to compare.&#10;            * @return True if the points are not equal, false otherwise.&#10;            */&#10;           bool operator!=(const Point&amp; other) const {&#10;               return !(*this == other);&#10;           }&#10;&#10;           /**&#10;            * @brief Gets the x-coordinate of the point.&#10;            * @return The x-coordinate.&#10;            */&#10;           T x() const {&#10;               return x_;&#10;           }&#10;&#10;           /**&#10;            * @brief Gets the y-coordinate of the point.&#10;            * @return The y-coordinate.&#10;            */&#10;           T y() const {&#10;               return y_;&#10;           }&#10;&#10;           /**&#10;            * @brief Sets the x-coordinate of the point.&#10;            * @param new_x The new x-coordinate.&#10;            * @return A reference to this point.&#10;            */&#10;           Point&amp; at_x(T new_x) {&#10;               x_ = new_x;&#10;               return *this;&#10;           }&#10;&#10;           /**&#10;            * @brief Sets the y-coordinate of the point.&#10;            * @param new_y The new y-coordinate.&#10;            * @return A reference to this point.&#10;            */&#10;           Point&amp; at_y(T new_y) {&#10;               y_ = new_y;&#10;               return *this;&#10;           }&#10;&#10;           /**&#10;            * @brief Calculates the distance from this point to another point.&#10;            * @tparam U The type of the other point's coordinates.&#10;            * @param other The other point.&#10;            * @return The distance between the two points.&#10;            */&#10;           template &lt;typename U&gt;&#10;           U distance_from(const Point&lt;U&gt;&amp; other) const {&#10;               U dx = static_cast&lt;U&gt;(other.x() - static_cast&lt;U&gt;(x_));&#10;               U dy = static_cast&lt;U&gt;(other.y() - static_cast&lt;U&gt;(y_));&#10;               return static_cast&lt;U&gt;(sqrt(dx * dx + dy * dy));&#10;           }&#10;&#10;           /**&#10;            * @brief Calculates the y-distance from this point to another point.&#10;            * @tparam U The type of the other point's coordinates.&#10;            * @param other The other point.&#10;            * @return The y-distance between the two points.&#10;            */&#10;           template &lt;typename U&gt;&#10;           U y_from(const Point&lt;U&gt;&amp; other) const {&#10;               return static_cast&lt;U&gt;(other.y() - y_);&#10;           }&#10;&#10;           /**&#10;            * @brief Calculates the x-distance from this point to another point.&#10;            * @tparam U The type of the other point's coordinates.&#10;            * @param other The other point.&#10;            * @return The x-distance between the two points.&#10;            */&#10;           template &lt;typename U&gt;&#10;           U x_from(const Point&lt;U&gt;&amp; other) const {&#10;               return static_cast&lt;U&gt;(other.x() - x_);&#10;           }&#10;&#10;           /**&#10;            * @brief Casts this point to another type.&#10;            * @tparam U The target type for the cast.&#10;            * @return A new Point with the coordinates cast to the target type.&#10;            */&#10;           template &lt;typename U&gt;&#10;           Point&lt;U&gt; cast() const {&#10;               return Point&lt;U&gt;(static_cast&lt;U&gt;(x_), static_cast&lt;U&gt;(y_));&#10;           }&#10;       };&#10;&#10;   }&#10;&#10;    /**&#10;        * @brief Concept to check if a type has an x member.&#10;        */&#10;    template &lt;typename T&gt;&#10;    concept HasXPosMember = requires(T t)&#10;   {&#10;       t.x &amp;&amp; std::is_arithmetic_v&lt;decltype(t.x)&gt;;&#10;   };&#10;&#10;    /**&#10;     * @brief Concept to check if a type has an x() method.&#10;     */&#10;    template &lt;typename T&gt;&#10;    concept HasXposMethod = requires(T t)&#10;    {&#10;        t.x() &amp;&amp; std::is_arithmetic_v&lt;decltype(t.x())&gt;;&#10;    };&#10;&#10;    /**&#10;     * @brief Concept to check if a type has an x position (member or method).&#10;     */&#10;    template &lt;typename T&gt;&#10;    concept HasXPos = HasXPosMember&lt;T&gt; || HasXposMethod&lt;T&gt;;&#10;&#10;    /**&#10;    * @brief Concept to check if a type has a y member.&#10;    */&#10;   template &lt;typename T&gt;&#10;   concept HasYPosMember = requires(T t)&#10;   {&#10;       t.y &amp;&amp; std::is_arithmetic_v&lt;decltype(t.y)&gt;;&#10;   };&#10;&#10;   /**&#10;    * @brief Concept to check if a type has a y() method.&#10;    */&#10;   template &lt;typename T&gt;&#10;   concept HasYposMethod = requires(T t)&#10;   {&#10;       t.y() &amp;&amp; std::is_arithmetic_v&lt;decltype(t.y())&gt;;&#10;   };&#10;&#10;   /**&#10;    * @brief Concept to check if a type has a y position (member or method).&#10;    */&#10;   template &lt;typename T&gt;&#10;   concept HasYPos = HasYPosMember&lt;T&gt; || HasYposMethod&lt;T&gt;;&#10;&#10;&#10;&#10;    namespace flat {&#10;        /**&#10;        * @brief Concept to check if a type satisfies both x and y position requirements.&#10;        */&#10;        template &lt;typename T&gt;&#10;        concept IsPoint = HasXPos&lt;T&gt; &amp;&amp; HasYPos&lt;T&gt;;&#10;&#10;        /**&#10; * @brief Concept to check if a type has a `point` member.&#10; * @tparam T The type to check.&#10; * @details This concept ensures that the type has a member variable named `point`.&#10; */&#10;        template &lt;typename T&gt;&#10;        concept HasPointMember = requires(T t)&#10;        {&#10;            t.point || t.origin || t.pos || t.position;&#10;        };&#10;&#10;        /**&#10;         * @brief Concept to check if a type has a `point()` method.&#10;         * @tparam T The type to check.&#10;         * @details This concept ensures that the type has a method named `point()`.&#10;         */&#10;        template &lt;typename T&gt;&#10;        concept HasPointMethod = requires(T t)&#10;        {&#10;            t.point() || t.origin() || t.pos() || t.position();&#10;        };&#10;&#10;        /**&#10;         * @brief Concept to check if a type has a `point` (member or method).&#10;         * @tparam T The type to check.&#10;         * @details This concept ensures that the type has either a member variable named `point`&#10;         * or a method named `point()`.&#10;         */&#10;        template &lt;typename T&gt;&#10;        concept HasPoint = HasPointMember&lt;T&gt; || HasPointMethod&lt;T&gt;;&#10;    }&#10;} // namespace mite&#10;" />
              <option name="updatedContent" value="module;&#10;#include &lt;type_traits&gt;&#10;#include &lt;cmath&gt;&#10;&#10;export module mite.point;&#10;&#10;export namespace mite {&#10;   namespace flat {&#10;       /**&#10;     * @brief A template class representing a 2D point with arithmetic operations.&#10;     * @tparam T The type of the coordinates, must be an arithmetic type.&#10;     */&#10;       template &lt;typename T&gt;&#10;       struct Point {&#10;           static_assert(std::is_arithmetic_v&lt;T&gt;, &quot;Point must be of an arithmetic type&quot;);&#10;&#10;       protected:&#10;           T x_; ///&lt; The x-coordinate of the point.&#10;           T y_; ///&lt; The y-coordinate of the point.&#10;&#10;       public:&#10;           /**&#10;            * @brief Constructs a Point with given x and y coordinates.&#10;            * @param x The x-coordinate (default is 0).&#10;            * @param y The y-coordinate (default is 0).&#10;            */&#10;           explicit Point(T x = 0, T y = 0) : x_(x), y_(y) {&#10;           }&#10;&#10;           /**&#10;            * @brief Adds two points.&#10;            * @param other The other point to add.&#10;            * @return A new Point that is the sum of this and the other point.&#10;            */&#10;           Point operator+(const Point&amp; other) const {&#10;               return Point(x_ + other.x_, y_ + other.y_);&#10;           }&#10;&#10;           /**&#10;            * @brief Adds another point to this point.&#10;            * @param other The other point to add.&#10;            * @return A reference to this point after addition.&#10;            */&#10;           Point&amp; operator+=(const Point&amp; other) {&#10;               x_ += other.x_;&#10;               y_ += other.y_;&#10;               return *this;&#10;           }&#10;&#10;           /**&#10;            * @brief Subtracts another point from this point.&#10;            * @param other The other point to subtract.&#10;            * @return A new Point that is the difference of this and the other point.&#10;            */&#10;           Point operator-(const Point&amp; other) const {&#10;               return Point(x_ - other.x_, y_ - other.y_);&#10;           }&#10;&#10;           /**&#10;            * @brief Subtracts another point from this point.&#10;            * @param other The other point to subtract.&#10;            * @return A reference to this point after subtraction.&#10;            */&#10;           Point&amp; operator-=(const Point&amp; other) {&#10;               x_ -= other.x_;&#10;               y_ -= other.y_;&#10;               return *this;&#10;           }&#10;&#10;           /**&#10;            * @brief Multiplies this point by a scalar.&#10;            * @param scalar The scalar value to multiply by.&#10;            * @return A new Point that is the result of the multiplication.&#10;            */&#10;           Point operator*(T scalar) const {&#10;               return Point(x_ * scalar, y_ * scalar);&#10;           }&#10;&#10;           /**&#10;            * @brief Divides this point by a scalar.&#10;            * @param scalar The scalar value to divide by.&#10;            * @return A new Point that is the result of the division.&#10;            */&#10;           Point operator/(T scalar) const {&#10;               return Point(x_ / scalar, y_ / scalar);&#10;           }&#10;&#10;           /**&#10;            * @brief Checks if two points are equal.&#10;            * @param other The other point to compare.&#10;            * @return True if the points are equal, false otherwise.&#10;            */&#10;           bool operator==(const Point&amp; other) const {&#10;               return x_ == other.x_ &amp;&amp; y_ == other.y_;&#10;           }&#10;&#10;           /**&#10;            * @brief Checks if two points are not equal.&#10;            * @param other The other point to compare.&#10;            * @return True if the points are not equal, false otherwise.&#10;            */&#10;           bool operator!=(const Point&amp; other) const {&#10;               return !(*this == other);&#10;           }&#10;&#10;           /**&#10;            * @brief Gets the x-coordinate of the point.&#10;            * @return The x-coordinate.&#10;            */&#10;           T x() const {&#10;               return x_;&#10;           }&#10;&#10;           /**&#10;            * @brief Gets the y-coordinate of the point.&#10;            * @return The y-coordinate.&#10;            */&#10;           T y() const {&#10;               return y_;&#10;           }&#10;&#10;           /**&#10;            * @brief Sets the x-coordinate of the point.&#10;            * @param new_x The new x-coordinate.&#10;            * @return A reference to this point.&#10;            */&#10;           Point&amp; at_x(T new_x) {&#10;               x_ = new_x;&#10;               return *this;&#10;           }&#10;&#10;           /**&#10;            * @brief Sets the y-coordinate of the point.&#10;            * @param new_y The new y-coordinate.&#10;            * @return A reference to this point.&#10;            */&#10;           Point&amp; at_y(T new_y) {&#10;               y_ = new_y;&#10;               return *this;&#10;           }&#10;&#10;           /**&#10;            * @brief Calculates the distance from this point to another point.&#10;            * @tparam U The type of the other point's coordinates.&#10;            * @param other The other point.&#10;            * @return The distance between the two points.&#10;            */&#10;           template &lt;typename U&gt;&#10;           U distance_from(const Point&lt;U&gt;&amp; other) const {&#10;               U dx = static_cast&lt;U&gt;(other.x() - static_cast&lt;U&gt;(x_));&#10;               U dy = static_cast&lt;U&gt;(other.y() - static_cast&lt;U&gt;(y_));&#10;               return static_cast&lt;U&gt;(sqrt(dx * dx + dy * dy));&#10;           }&#10;&#10;           /**&#10;            * @brief Calculates the y-distance from this point to another point.&#10;            * @tparam U The type of the other point's coordinates.&#10;            * @param other The other point.&#10;            * @return The y-distance between the two points.&#10;            */&#10;           template &lt;typename U&gt;&#10;           U y_from(const Point&lt;U&gt;&amp; other) const {&#10;               return static_cast&lt;U&gt;(other.y() - y_);&#10;           }&#10;&#10;           /**&#10;            * @brief Calculates the x-distance from this point to another point.&#10;            * @tparam U The type of the other point's coordinates.&#10;            * @param other The other point.&#10;            * @return The x-distance between the two points.&#10;            */&#10;           template &lt;typename U&gt;&#10;           U x_from(const Point&lt;U&gt;&amp; other) const {&#10;               return static_cast&lt;U&gt;(other.x() - x_);&#10;           }&#10;&#10;           /**&#10;            * @brief Casts this point to another type.&#10;            * @tparam U The target type for the cast.&#10;            * @return A new Point with the coordinates cast to the target type.&#10;            */&#10;           template &lt;typename U&gt;&#10;           Point&lt;U&gt; cast() const {&#10;               return Point&lt;U&gt;(static_cast&lt;U&gt;(x_), static_cast&lt;U&gt;(y_));&#10;           }&#10;       };&#10;&#10;   }&#10;&#10;    /**&#10;        * @brief Concept to check if a type has an x member.&#10;        */&#10;    template &lt;typename T&gt;&#10;    concept HasXPosMember = requires(T t)&#10;   {&#10;       t.x &amp;&amp; std::is_arithmetic_v&lt;decltype(t.x)&gt;;&#10;   };&#10;&#10;    /**&#10;     * @brief Concept to check if a type has an x() method.&#10;     */&#10;    template &lt;typename T&gt;&#10;    concept HasXposMethod = requires(T t)&#10;    {&#10;        t.x() &amp;&amp; std::is_arithmetic_v&lt;decltype(t.x())&gt;;&#10;    };&#10;&#10;    /**&#10;     * @brief Concept to check if a type has an x position (member or method).&#10;     */&#10;    template &lt;typename T&gt;&#10;    concept HasXPos = HasXPosMember&lt;T&gt; || HasXposMethod&lt;T&gt;;&#10;&#10;    /**&#10;    * @brief Concept to check if a type has a y member.&#10;    */&#10;   template &lt;typename T&gt;&#10;   concept HasYPosMember = requires(T t)&#10;   {&#10;       t.y &amp;&amp; std::is_arithmetic_v&lt;decltype(t.y)&gt;;&#10;   };&#10;&#10;   /**&#10;    * @brief Concept to check if a type has a y() method.&#10;    */&#10;   template &lt;typename T&gt;&#10;   concept HasYposMethod = requires(T t)&#10;   {&#10;       t.y() &amp;&amp; std::is_arithmetic_v&lt;decltype(t.y())&gt;;&#10;   };&#10;&#10;   /**&#10;    * @brief Concept to check if a type has a y position (member or method).&#10;    */&#10;   template &lt;typename T&gt;&#10;   concept HasYPos = HasYPosMember&lt;T&gt; || HasYposMethod&lt;T&gt;;&#10;&#10;&#10;&#10;    namespace flat {&#10;        /**&#10;        * @brief Concept to check if a type satisfies both x and y position requirements.&#10;        */&#10;        template &lt;typename T&gt;&#10;        concept IsPoint = HasXPos&lt;T&gt; &amp;&amp; HasYPos&lt;T&gt;;&#10;&#10;        /**&#10; * @brief Concept to check if a type has a `point` member.&#10; * @tparam T The type to check.&#10; * @details This concept ensures that the type has a member variable named `point`.&#10; */&#10;        template &lt;typename T&gt;&#10;        concept HasPointMember = requires(T t)&#10;        {&#10;            t.point;&#10;        } || requires(T t) {&#10;            t.origin;&#10;        } || requires(T t) {&#10;            t.pos;&#10;        } || requires(T t) {&#10;            t.position;&#10;        };&#10;&#10;        /**&#10;         * @brief Concept to check if a type has a `point()` method.&#10;         * @tparam T The type to check.&#10;         * @details This concept ensures that the type has a method named `point()`.&#10;         */&#10;        template &lt;typename T&gt;&#10;        concept HasPointMethod = requires(T t)&#10;        {&#10;            t.point();&#10;        } || requires(T t) {&#10;            t.origin();&#10;        } || requires(T t) {&#10;            t.pos();&#10;        } || requires(T t) {&#10;            t.position();&#10;        };&#10;&#10;        /**&#10;         * @brief Concept to check if a type has a `point` (member or method).&#10;         * @tparam T The type to check.&#10;         * @details This concept ensures that the type has either a member variable named `point`&#10;         * or a method named `point()`.&#10;         */&#10;        template &lt;typename T&gt;&#10;        concept HasPoint = HasPointMember&lt;T&gt; || HasPointMethod&lt;T&gt;;&#10;    }&#10;} // namespace mite" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/include/modules/mite/rect.ixx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/modules/mite/rect.ixx" />
              <option name="updatedContent" value="module;&#10;#include &lt;type_traits&gt;&#10;&#10;export module mite.rect;&#10;&#10;import mite.size;&#10;import mite.point;&#10;&#10;export namespace mite {&#10;&#10;    /**&#10;     * @brief A template class representing a 2D rectangle with geometric operations.&#10;     * @tparam T The type of the coordinates and dimensions, must be an arithmetic type.&#10;     */&#10;    template &lt;typename T&gt;&#10;    struct Rect {&#10;        static_assert(std::is_arithmetic_v&lt;T&gt;, &quot;Rect must be of an arithmetic type&quot;);&#10;&#10;    protected:&#10;        flat::Point&lt;T&gt; origin_; ///&lt; The origin point (bottom-left corner) of the rectangle.&#10;        flat::Size&lt;T&gt; size_; ///&lt; The size (width and height) of the rectangle.&#10;&#10;    public:&#10;&#10;        /**&#10;         * @brief Constructs a Rect with given origin point and size.&#10;         * @param origin The origin point of the rectangle (default is Point at 0,0).&#10;         * @param size The size of the rectangle (default is Size with 0,0).&#10;         */&#10;        explicit Rect(flat::Point&lt;T&gt; origin = flat::Point&lt;T&gt;(), flat::Size&lt;T&gt; size = flat::Size&lt;T&gt;())&#10;            : origin_(origin), size_(size) {}&#10;&#10;        /**&#10;         * @brief Constructs a Rect with given origin point, width and height.&#10;         * @param origin The origin point of the rectangle.&#10;         * @param width The width of the rectangle.&#10;         * @param height The height of the rectangle.&#10;         */&#10;        explicit Rect(flat::Point&lt;T&gt; origin, T width, T height)&#10;            : origin_(origin), size_(flat::Size&lt;T&gt;(height, width)) {}&#10;&#10;        /**&#10;         * @brief Constructs a Rect with given coordinates and size.&#10;         * @param x The x-coordinate of the origin.&#10;         * @param y The y-coordinate of the origin.&#10;         * @param size The size of the rectangle.&#10;         */&#10;        explicit Rect(T x, T y, flat::Size&lt;T&gt; size)&#10;            : origin_(flat::Point&lt;T&gt;(x, y)), size_(size) {}&#10;&#10;        /**&#10;         * @brief Constructs a Rect with given coordinates, width and height.&#10;         * @param x The x-coordinate of the origin.&#10;         * @param y The y-coordinate of the origin.&#10;         * @param width The width of the rectangle.&#10;         * @param height The height of the rectangle.&#10;         */&#10;        explicit Rect(T x, T y, T width, T height)&#10;            : origin_(flat::Point&lt;T&gt;(x, y)), size_(flat::Size&lt;T&gt;(height, width)) {}&#10;&#10;        /**&#10;         * @brief Gets the origin point of the rectangle.&#10;         * @return The origin point of the rectangle.&#10;         */&#10;        flat::Point&lt;T&gt; origin() const {&#10;            return origin_;&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the size of the rectangle.&#10;         * @return The size of the rectangle.&#10;         */&#10;        flat::Size&lt;T&gt; size() const {&#10;            return size_;&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the width of the rectangle.&#10;         * @return The width of the rectangle.&#10;         */&#10;        T width() const {&#10;            return size_.width();&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the height of the rectangle.&#10;         * @return The height of the rectangle.&#10;         */&#10;        T height() const {&#10;            return size_.height();&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the origin point of the rectangle.&#10;         * @param new_origin The new origin point.&#10;         */&#10;        void set_origin(const flat::Point&lt;T&gt;&amp; new_origin) {&#10;            origin_ = new_origin;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the size of the rectangle.&#10;         * @param new_size The new size.&#10;         */&#10;        void set_size(const flat::Size&lt;T&gt;&amp; new_size) {&#10;            size_ = new_size;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the width of the rectangle.&#10;         * @param new_width The new width.&#10;         */&#10;        void set_width(T new_width) {&#10;            size_.of_width(new_width);&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the height of the rectangle.&#10;         * @param new_height The new height.&#10;         */&#10;        void set_height(T new_height) {&#10;            size_.of_height(new_height);&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the x-coordinate of the rectangle's origin.&#10;         * @return The x-coordinate of the origin point.&#10;         */&#10;        T x() const {&#10;            return origin_.x();&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the y-coordinate of the rectangle's origin.&#10;         * @return The y-coordinate of the origin point.&#10;         */&#10;        T y() const {&#10;            return origin_.y();&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the x-coordinate of the rectangle's origin.&#10;         * @param new_x The new x-coordinate.&#10;         * @return A reference to this rectangle for method chaining.&#10;         */&#10;        Rect&amp; at_x(T new_x) {&#10;            origin_.at_x(new_x);&#10;            return *this;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the y-coordinate of the rectangle's origin.&#10;         * @param new_y The new y-coordinate.&#10;         * @return A reference to this rectangle for method chaining.&#10;         */&#10;        Rect&amp; at_y(T new_y) {&#10;            origin_.at_y(new_y);&#10;            return *this;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the origin point of the rectangle.&#10;         * @param new_origin The new origin point.&#10;         * @return A reference to this rectangle for method chaining.&#10;         */&#10;        Rect&amp; at(const flat::Point&lt;T&gt;&amp; new_origin) {&#10;            origin_ = new_origin;&#10;            return *this;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the size of the rectangle.&#10;         * @param new_size The new size.&#10;         * @return A reference to this rectangle for method chaining.&#10;         */&#10;        Rect&amp; of_size(const flat::Size&lt;T&gt;&amp; new_size) {&#10;            size_ = new_size;&#10;            return *this;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the width of the rectangle.&#10;         * @param new_width The new width.&#10;         * @return A reference to this rectangle for method chaining.&#10;         */&#10;        Rect&amp; of_width(T new_width) {&#10;            size_.of_width(new_width);&#10;            return *this;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the height of the rectangle.&#10;         * @param new_height The new height.&#10;         * @return A reference to this rectangle for method chaining.&#10;         */&#10;        Rect&amp; of_height(T new_height) {&#10;            size_.of_height(new_height);&#10;            return *this;&#10;        }&#10;&#10;        /**&#10;         * @brief Checks if two rectangles are equal.&#10;         * @param other The other rectangle to compare.&#10;         * @return True if the rectangles have the same origin and size, false otherwise.&#10;         */&#10;        bool operator==(const Rect&amp; other) const {&#10;            return origin_ == other.origin_ &amp;&amp; size_ == other.size_;&#10;        }&#10;&#10;        /**&#10;         * @brief Checks if two rectangles are not equal.&#10;         * @param other The other rectangle to compare.&#10;         * @return True if the rectangles are not equal, false otherwise.&#10;         */&#10;        bool operator!=(const Rect&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;&#10;        /**&#10;         * @brief Calculates the area of the rectangle.&#10;         * @return The area of the rectangle (width * height).&#10;         */&#10;        T area() const {&#10;            return size_.width() * size_.height();&#10;        }&#10;&#10;        /**&#10;         * @brief Calculates the perimeter of the rectangle.&#10;         * @return The perimeter of the rectangle (2 * (width + height)).&#10;         */&#10;        T perimeter() const {&#10;            return static_cast&lt;T&gt;(2) * (size_.width() + size_.height());&#10;        }&#10;&#10;        /**&#10;         * @brief Checks if this rectangle can fit another rectangle within its bounds.&#10;         * @param other The other rectangle to check.&#10;         * @return True if the other rectangle can fit entirely within this rectangle, false otherwise.&#10;         */&#10;        bool can_fit(const Rect&amp; other) const {&#10;            return other.origin_.x() &gt;= origin_.x() &amp;&amp;&#10;                   other.origin_.y() &gt;= origin_.y() &amp;&amp;&#10;                   (other.origin_.x() + other.size_.width()) &lt;= (origin_.x() + size_.width()) &amp;&amp;&#10;                   (other.origin_.y() + other.size_.height()) &lt;= (origin_.y() + size_.height());&#10;        }&#10;&#10;        /**&#10;         * @brief Checks if this rectangle can fit a size within its bounds.&#10;         * @param size The size to check.&#10;         * @return True if the size can fit within this rectangle, false otherwise.&#10;         */&#10;        bool can_fit(const flat::Size&lt;T&gt;&amp; size) const {&#10;            return size_.can_fit(size);&#10;        }&#10;&#10;        /**&#10;         * @brief Checks if a point is contained within the rectangle.&#10;         * @param point The point to check.&#10;         * @return True if the point is within the rectangle's bounds (inclusive), false otherwise.&#10;         */&#10;        bool contains(const flat::Point&lt;T&gt;&amp; point) const {&#10;            return point.x() &gt;= origin_.x() &amp;&amp; point.x() &lt;= (origin_.x() + size_.width()) &amp;&amp;&#10;                   point.y() &gt;= origin_.y() &amp;&amp; point.y() &lt;= (origin_.y() + size_.height());&#10;        }&#10;&#10;        /**&#10;         * @brief Checks if this rectangle intersects with another rectangle.&#10;         * @param other The other rectangle to check for intersection.&#10;         * @return True if the rectangles intersect, false otherwise.&#10;         */&#10;        bool intersects(const Rect&amp; other) const {&#10;            return !(origin_.x() + size_.width() &lt; other.origin_.x() ||&#10;                     origin_.x() &gt; other.origin_.x() + other.size_.width() ||&#10;                     origin_.y() + size_.height() &lt; other.origin_.y() ||&#10;                     origin_.y() &gt; other.origin_.y() + other.size_.height());&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the top-left corner of the rectangle.&#10;         * @return The top-left corner point.&#10;         */&#10;        flat::Point&lt;T&gt; top_left() const {&#10;            return flat::Point&lt;T&gt;(origin_.x(), origin_.y() + size_.height());&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the top-right corner of the rectangle.&#10;         * @return The top-right corner point.&#10;         */&#10;        flat::Point&lt;T&gt; top_right() const {&#10;            return flat::Point&lt;T&gt;(origin_.x() + size_.width(), origin_.y() + size_.height());&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the bottom-left corner of the rectangle (same as origin).&#10;         * @return The bottom-left corner point.&#10;         */&#10;        flat::Point&lt;T&gt; bottom_left() const {&#10;            return origin_;&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the bottom-right corner of the rectangle.&#10;         * @return The bottom-right corner point.&#10;         */&#10;        flat::Point&lt;T&gt; bottom_right() const {&#10;            return flat::Point&lt;T&gt;(origin_.x() + size_.width(), origin_.y());&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the center point of the rectangle.&#10;         * @return The center point of the rectangle.&#10;         */&#10;        flat::Point&lt;T&gt; center() const {&#10;            return flat::Point&lt;T&gt;(&#10;                origin_.x() + size_.width() / static_cast&lt;T&gt;(2),&#10;                origin_.y() + size_.height() / static_cast&lt;T&gt;(2)&#10;            );&#10;        }&#10;&#10;        /**&#10;         * @brief Casts this rectangle to another numeric type.&#10;         * @tparam U The target type for the cast.&#10;         * @return A new Rect with the origin and size cast to the target type.&#10;         */&#10;        template &lt;typename U&gt;&#10;        Rect&lt;U&gt; cast() const {&#10;            return Rect&lt;U&gt;(&#10;                origin_.template cast&lt;U&gt;(),&#10;                flat::Size&lt;U&gt;(static_cast&lt;U&gt;(size_.height()), static_cast&lt;U&gt;(size_.width()))&#10;            );&#10;        }&#10;&#10;        /**&#10;         * @brief Checks if this rectangle is a square.&#10;         * @return True if width equals height, false otherwise.&#10;         */&#10;        bool is_square() const {&#10;            return size_.width() == size_.height();&#10;        }&#10;&#10;        /**&#10;         * @brief Scales the rectangle by a factor.&#10;         * @param factor The scaling factor.&#10;         * @return A new Rect that is scaled by the given factor.&#10;         */&#10;        Rect scale(T factor) const {&#10;            return Rect(origin_, size_ * factor);&#10;        }&#10;&#10;        /**&#10;         * @brief Translates the rectangle by a given offset.&#10;         * @param offset The offset to translate by.&#10;         * @return A new Rect that is translated by the given offset.&#10;         */&#10;        Rect translate(const flat::Point&lt;T&gt;&amp; offset) const {&#10;            return Rect(origin_ + offset, size_);&#10;        }&#10;&#10;        /**&#10;         * @brief Expands the rectangle by a given amount in all directions.&#10;         * @param amount The amount to expand by.&#10;         * @return A new Rect that is expanded by the given amount.&#10;         */&#10;        Rect expand(T amount) const {&#10;            return Rect(&#10;                flat::Point&lt;T&gt;(origin_.x() - amount, origin_.y() - amount),&#10;                flat::Size&lt;T&gt;(size_.height() + static_cast&lt;T&gt;(2) * amount, &#10;                              size_.width() + static_cast&lt;T&gt;(2) * amount)&#10;            );&#10;        }&#10;&#10;        /**&#10;         * @brief Contracts the rectangle by a given amount in all directions.&#10;         * @param amount The amount to contract by.&#10;         * @return A new Rect that is contracted by the given amount.&#10;         */&#10;        Rect contract(T amount) const {&#10;            return expand(-amount);&#10;        }&#10;    };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/include/modules/mite/square.ixx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/modules/mite/square.ixx" />
              <option name="originalContent" value="module;&#10;&#10;export module mite.square;&#10;&#10;import mite.size;&#10;import mite.point;&#10;&#10;export namespace mite {&#10;&#10;&#10;    /**&#10;     * @brief A template class representing a 2D square with geometric operations.&#10;     * @tparam T The type of the coordinates and dimensions, must be an arithmetic type.&#10;     */&#10;    template &lt;typename T&gt;&#10;    struct Square {&#10;&#10;    protected:&#10;        flat::Point&lt;T&gt; origin_; ///&lt; The origin point (bottom-left corner) of the square.&#10;        T len_; ///&lt; The side length of the square.&#10;&#10;    public:&#10;&#10;        /**&#10;         * @brief Constructs a Square with given origin point and side length.&#10;         * @param origin The origin point of the square (default is Point at 0,0).&#10;         * @param len The side length of the square (default is 0).&#10;         */&#10;        explicit Square(flat::Point&lt;T&gt; origin = flat::Point&lt;T&gt;(), T len = 0)&#10;            : origin_(origin), len_(len) {}&#10;&#10;&#10;        /**&#10;         * @brief Gets the origin point of the square.&#10;         * @return The origin point of the square.&#10;         */&#10;        flat::Point&lt;T&gt; origin() const {&#10;            return origin_;&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Gets the side length of the square.&#10;         * @return The side length of the square.&#10;         */&#10;        T length() const {&#10;            return len_;&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the width of the square (same as length for a square).&#10;         * @return The width of the square.&#10;         */&#10;        T width() const {&#10;            return len_;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the origin point of the square.&#10;         * @param new_origin The new origin point.&#10;         */&#10;        void set_origin(const flat::Point&lt;T&gt;&amp; new_origin) {&#10;            origin_ = new_origin;&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Sets the side length of the square.&#10;         * @param new_len The new side length.&#10;         */&#10;        void set_length(T new_len) {&#10;            len_ = new_len;&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the x-coordinate of the square's origin.&#10;         * @return The x-coordinate of the origin point.&#10;         */&#10;        T x() const {&#10;            return origin_.x();&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the y-coordinate of the square's origin.&#10;         * @return The y-coordinate of the origin point.&#10;         */&#10;        T y() const {&#10;            return origin_.y();&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the x-coordinate of the square's origin.&#10;         * @param new_x The new x-coordinate.&#10;         * @return A reference to this square for method chaining.&#10;         */&#10;        Square&amp; at_x(T new_x) {&#10;            origin_.at_x(new_x);&#10;            return *this;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the y-coordinate of the square's origin.&#10;         * @param new_y The new y-coordinate.&#10;         * @return A reference to this square for method chaining.&#10;         */&#10;        Square&amp; at_y(T new_y) {&#10;            origin_.at_y(new_y);&#10;            return *this;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the origin point of the square.&#10;         * @param new_origin The new origin point.&#10;         * @return A reference to this square for method chaining.&#10;         */&#10;        Square &amp; at(const flat::Point&lt;T&gt;&amp; new_origin) {&#10;            origin_ = new_origin;&#10;            return *this;&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Checks if two squares are equal.&#10;         * @param other The other square to compare.&#10;         * @return True if the squares have the same origin and length, false otherwise.&#10;         */&#10;        bool operator==(const Square&amp; other) const {&#10;            return origin_ == other.origin_ &amp;&amp; len_ == other.len_;&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Checks if two squares are not equal.&#10;         * @param other The other square to compare.&#10;         * @return True if the squares are not equal, false otherwise.&#10;         */&#10;        bool operator!=(const Square&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Calculates the area of the square.&#10;         * @return The area of the square (length squared).&#10;         */&#10;        T area() const {&#10;            return len_ * len_;&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Checks if this square can fit another square within its bounds.&#10;         * @param other The other square to check.&#10;         * @return True if the other square can fit within this square, false otherwise.&#10;         */&#10;        bool can_fit(const Square&amp; other) const {&#10;            return len_ &gt;= other.len_ &amp;&amp; origin_.x() &lt;= other.origin_.x()&#10;                &amp;&amp; origin_.y() &lt;= other.origin_.y();&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Checks if a point is contained within the square.&#10;         * @param point The point to check.&#10;         * @return True if the point is within the square's bounds (inclusive), false otherwise.&#10;         */&#10;        bool contains(const flat::Point&lt;T&gt;&amp; point) const {&#10;            return point.x() &gt;= origin_.x() &amp;&amp; point.x() &lt;= (origin_.x() + len_)&#10;                &amp;&amp; point.y() &gt;= origin_.y() &amp;&amp; point.y() &lt;= (origin_.y() + len_);&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Checks if this square intersects with another square.&#10;         * @param other The other square to check for intersection.&#10;         * @return True if the squares intersect, false otherwise.&#10;         */&#10;        bool intersects(const Square&amp; other) const {&#10;            return !(origin_.x() + len_ &lt; other.origin_.x() ||&#10;                     origin_.x() &gt; other.origin_.x() + other.len_ ||&#10;                     origin_.y() + len_ &lt; other.origin_.y() ||&#10;                     origin_.y() &gt; other.origin_.y() + other.len_);&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Casts this square to another numeric type.&#10;         * @tparam U The target type for the cast.&#10;         * @return A new Square with the origin and length cast to the target type.&#10;         */&#10;        template &lt;typename U&gt;&#10;        Square&lt;U&gt; cast() const {&#10;            return Square&lt;U&gt;(origin_.template cast&lt;U&gt;(), static_cast&lt;U&gt;(len_));&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Gets the size of the square as a Size object.&#10;         * @return A Size object with height and width both equal to the square's length.&#10;         */&#10;        flat::Size&lt;T&gt; size() const {&#10;            return flat::Size&lt;T&gt;(len_, len_);&#10;        }&#10;    };&#10;}" />
              <option name="updatedContent" value="module;&#10;#include &lt;type_traits&gt;&#10;&#10;export module mite.square;&#10;&#10;import mite.size;&#10;import mite.point;&#10;&#10;export namespace mite {&#10;&#10;&#10;    /**&#10;     * @brief A template class representing a 2D square with geometric operations.&#10;     * @tparam T The type of the coordinates and dimensions, must be an arithmetic type.&#10;     */&#10;    template &lt;typename T&gt;&#10;    struct Square {&#10;        static_assert(std::is_arithmetic_v&lt;T&gt;, &quot;Square must be of an arithmetic type&quot;);&#10;&#10;    protected:&#10;        flat::Point&lt;T&gt; origin_; ///&lt; The origin point (bottom-left corner) of the square.&#10;        T len_; ///&lt; The side length of the square.&#10;&#10;    public:&#10;&#10;        /**&#10;         * @brief Constructs a Square with given origin point and side length.&#10;         * @param origin The origin point of the square (default is Point at 0,0).&#10;         * @param len The side length of the square (default is 0).&#10;         */&#10;        explicit Square(flat::Point&lt;T&gt; origin = flat::Point&lt;T&gt;(), T len = 0)&#10;            : origin_(origin), len_(len) {}&#10;&#10;&#10;        /**&#10;         * @brief Gets the origin point of the square.&#10;         * @return The origin point of the square.&#10;         */&#10;        flat::Point&lt;T&gt; origin() const {&#10;            return origin_;&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Gets the side length of the square.&#10;         * @return The side length of the square.&#10;         */&#10;        T length() const {&#10;            return len_;&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the width of the square (same as length for a square).&#10;         * @return The width of the square.&#10;         */&#10;        T width() const {&#10;            return len_;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the origin point of the square.&#10;         * @param new_origin The new origin point.&#10;         */&#10;        void set_origin(const flat::Point&lt;T&gt;&amp; new_origin) {&#10;            origin_ = new_origin;&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Sets the side length of the square.&#10;         * @param new_len The new side length.&#10;         */&#10;        void set_length(T new_len) {&#10;            len_ = new_len;&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the x-coordinate of the square's origin.&#10;         * @return The x-coordinate of the origin point.&#10;         */&#10;        T x() const {&#10;            return origin_.x();&#10;        }&#10;&#10;        /**&#10;         * @brief Gets the y-coordinate of the square's origin.&#10;         * @return The y-coordinate of the origin point.&#10;         */&#10;        T y() const {&#10;            return origin_.y();&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the x-coordinate of the square's origin.&#10;         * @param new_x The new x-coordinate.&#10;         * @return A reference to this square for method chaining.&#10;         */&#10;        Square&amp; at_x(T new_x) {&#10;            origin_.at_x(new_x);&#10;            return *this;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the y-coordinate of the square's origin.&#10;         * @param new_y The new y-coordinate.&#10;         * @return A reference to this square for method chaining.&#10;         */&#10;        Square&amp; at_y(T new_y) {&#10;            origin_.at_y(new_y);&#10;            return *this;&#10;        }&#10;&#10;        /**&#10;         * @brief Sets the origin point of the square.&#10;         * @param new_origin The new origin point.&#10;         * @return A reference to this square for method chaining.&#10;         */&#10;        Square &amp; at(const flat::Point&lt;T&gt;&amp; new_origin) {&#10;            origin_ = new_origin;&#10;            return *this;&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Checks if two squares are equal.&#10;         * @param other The other square to compare.&#10;         * @return True if the squares have the same origin and length, false otherwise.&#10;         */&#10;        bool operator==(const Square&amp; other) const {&#10;            return origin_ == other.origin_ &amp;&amp; len_ == other.len_;&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Checks if two squares are not equal.&#10;         * @param other The other square to compare.&#10;         * @return True if the squares are not equal, false otherwise.&#10;         */&#10;        bool operator!=(const Square&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Calculates the area of the square.&#10;         * @return The area of the square (length squared).&#10;         */&#10;        T area() const {&#10;            return len_ * len_;&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Checks if this square can fit another square within its bounds.&#10;         * @param other The other square to check.&#10;         * @return True if the other square can fit entirely within this square, false otherwise.&#10;         */&#10;        bool can_fit(const Square&amp; other) const {&#10;            return other.origin_.x() &gt;= origin_.x() &amp;&amp; &#10;                   other.origin_.y() &gt;= origin_.y() &amp;&amp;&#10;                   (other.origin_.x() + other.len_) &lt;= (origin_.x() + len_) &amp;&amp;&#10;                   (other.origin_.y() + other.len_) &lt;= (origin_.y() + len_);&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Checks if a point is contained within the square.&#10;         * @param point The point to check.&#10;         * @return True if the point is within the square's bounds (inclusive), false otherwise.&#10;         */&#10;        bool contains(const flat::Point&lt;T&gt;&amp; point) const {&#10;            return point.x() &gt;= origin_.x() &amp;&amp; point.x() &lt;= (origin_.x() + len_)&#10;                &amp;&amp; point.y() &gt;= origin_.y() &amp;&amp; point.y() &lt;= (origin_.y() + len_);&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Checks if this square intersects with another square.&#10;         * @param other The other square to check for intersection.&#10;         * @return True if the squares intersect, false otherwise.&#10;         */&#10;        bool intersects(const Square&amp; other) const {&#10;            return !(origin_.x() + len_ &lt; other.origin_.x() ||&#10;                     origin_.x() &gt; other.origin_.x() + other.len_ ||&#10;                     origin_.y() + len_ &lt; other.origin_.y() ||&#10;                     origin_.y() &gt; other.origin_.y() + other.len_);&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Casts this square to another numeric type.&#10;         * @tparam U The target type for the cast.&#10;         * @return A new Square with the origin and length cast to the target type.&#10;         */&#10;        template &lt;typename U&gt;&#10;        Square&lt;U&gt; cast() const {&#10;            return Square&lt;U&gt;(origin_.template cast&lt;U&gt;(), static_cast&lt;U&gt;(len_));&#10;        }&#10;&#10;&#10;        /**&#10;         * @brief Gets the size of the square as a Size object.&#10;         * @return A Size object with height and width both equal to the square's length.&#10;         */&#10;        flat::Size&lt;T&gt; size() const {&#10;            return flat::Size&lt;T&gt;(len_, len_);&#10;        }&#10;    };&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>