<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/include/modules/mite/flat/point.ixx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/modules/mite/flat/point.ixx" />
              <option name="originalContent" value="module;&#10;#include &lt;type_traits&gt;&#10;&#10;export module mite.point;&#10;&#10;export namespace mite {&#10;&#10;    template&lt;typename  T&gt;&#10;    struct Point {&#10;        static_assert(std::is_arithmetic_v&lt;T&gt;, &quot;Point must be of an arithmetic type&quot;);&#10;&#10;    protected:&#10;        T x_;&#10;        T y_;&#10;&#10;    public:&#10;&#10;        explicit Point(T x = 0, T y = 0) : x_(x), y_(y) {}&#10;&#10;        // Addition operator&#10;        Point operator+(const Point&amp; other) const {&#10;            return Point(x_ + other.x_, y_ + other.y_);&#10;        }&#10;&#10;        Point operator+(const Point other) const {&#10;            return Point(x_ + other.x_, y_ + other.y_);&#10;        }&#10;&#10;        Point&amp; operator+=(const Point&amp; other) {&#10;            x_ += other.x_;&#10;            y_ += other.y_;&#10;            return *this;&#10;        }&#10;&#10;        Point&amp; operator+=(const Point other) {&#10;            x_ += other.x_;&#10;            y_ += other.y_;&#10;            return *this;&#10;        }&#10;&#10;        // Subtraction operator&#10;        Point operator-(const Point&amp; other) const {&#10;            return Point(x_ - other.x_, y_ - other.y_);&#10;        }&#10;&#10;        Point operator-(const Point other) const {&#10;            return Point(x_ - other.x_, y_ - other.y_);&#10;        }&#10;&#10;        Point&amp; operator-=(const Point&amp; other) {&#10;            x_ -= other.x_;&#10;            y_ -= other.y_;&#10;            return *this;&#10;        }&#10;&#10;        Point&amp; operator-=(const Point other) {&#10;            x_ -= other.x_;&#10;            y_ -= other.y_;&#10;            return *this;&#10;        }&#10;&#10;        // Scalar multiplication&#10;        Point operator*(T scalar) const {&#10;            return Point(x_ * scalar, y_ * scalar);&#10;        }&#10;&#10;        // Scalar division&#10;        Point operator/(T scalar) const {&#10;            return Point(x_ / scalar, y_ / scalar);&#10;        }&#10;&#10;        // Equality operator&#10;        bool operator==(const Point&amp; other) const {&#10;            return x_ == other.x_ &amp;&amp; y_ == other.y_;&#10;        }&#10;&#10;        // Inequality operator&#10;        bool operator!=(const Point&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;&#10;        T x() const {&#10;            return x_;&#10;        }&#10;&#10;        T y() const {&#10;            return y_;&#10;        }&#10;&#10;&#10;        Point&amp; at_x(T new_x) {&#10;            x_ = new_x;&#10;            return *this;&#10;        }&#10;&#10;        Point&amp; at_y(T new_y) {&#10;            y_ = new_y;&#10;            return *this;&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U distance_from(const Point&lt;U&gt;&amp; other) const {&#10;            U dx = static_cast&lt;U&gt;(other.x() - static_cast&lt;U&gt;(x_));&#10;            U dy = static_cast&lt;U&gt;(other.y() - static_cast&lt;U&gt;(y_));&#10;            return static_cast&lt;U&gt;(sqrt(dx * dx + dy * dy));&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U distance_from(const Point&lt;U&gt; other) const {&#10;            U dx = static_cast&lt;U&gt;(other.x() - static_cast&lt;U&gt;(x_));&#10;            U dy = static_cast&lt;U&gt;(other.y() - static_cast&lt;U&gt;(y_));&#10;            return static_cast&lt;U&gt;(sqrt(dx * dx + dy * dy));&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U y_from(const Point&lt;U&gt;&amp; other) const {&#10;            return static_cast&lt;U&gt;(other.y() - y_);&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U y_from(const Point&lt;U&gt; other) const {&#10;            return static_cast&lt;U&gt;(other.y() - y_);&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U x_from(const Point&lt;U&gt;&amp; other) const {&#10;            return static_cast&lt;U&gt;(other.x() - x_);&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U x_from(const Point&lt;U&gt; other) const {&#10;            return static_cast&lt;U&gt;(other.x() - x_);&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        Point&lt;U&gt; cast() const {&#10;            return Point&lt;U&gt;(static_cast&lt;U&gt;(x_), static_cast&lt;U&gt;(y_));&#10;        }&#10;&#10;    };&#10;&#10;    namespace point {&#10;        template&lt;typename T&gt;&#10;    concept HasXPosMember = requires(T t) {&#10;            t.x;&#10;    };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasXposMethod = requires(T t) {&#10;            t.y();&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasXPos = HasXPosMember&lt;T&gt; || HasXposMethod&lt;T&gt;;&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasYPosMember = requires(T t) {&#10;            t.y;&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasYposMethod = requires(T t) {&#10;            t.y();&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasYPos = HasYPosMember&lt;T&gt; || HasYposMethod&lt;T&gt;;&#10;    }&#10;&#10;    template&lt;typename T&gt;&#10;    concept IsPoint = point::HasXPos&lt;T&gt; &amp;&amp; point::HasYPos&lt;T&gt;;&#10;&#10;} // namespace mite" />
              <option name="updatedContent" value="module;&#10;#include &lt;type_traits&gt;&#10;&#10;export module mite.point;&#10;&#10;export namespace mite {&#10;&#10;    template&lt;typename  T&gt;&#10;    struct Point {&#10;        static_assert(std::is_arithmetic_v&lt;T&gt;, &quot;Point must be of an arithmetic type&quot;);&#10;&#10;    protected:&#10;        T x_;&#10;        T y_;&#10;&#10;    public:&#10;&#10;        explicit Point(T x = 0, T y = 0) : x_(x), y_(y) {}&#10;&#10;        // Addition operator&#10;        Point operator+(const Point&amp; other) const {&#10;            return Point(x_ + other.x_, y_ + other.y_);&#10;        }&#10;&#10;        Point&amp; operator+=(const Point&amp; other) {&#10;            x_ += other.x_;&#10;            y_ += other.y_;&#10;            return *this;&#10;        }&#10;&#10;        // Subtraction operator&#10;        Point operator-(const Point&amp; other) const {&#10;            return Point(x_ - other.x_, y_ - other.y_);&#10;        }&#10;&#10;        Point&amp; operator-=(const Point&amp; other) {&#10;            x_ -= other.x_;&#10;            y_ -= other.y_;&#10;            return *this;&#10;        }&#10;&#10;        // Scalar multiplication&#10;        Point operator*(T scalar) const {&#10;            return Point(x_ * scalar, y_ * scalar);&#10;        }&#10;&#10;        // Scalar division&#10;        Point operator/(T scalar) const {&#10;            return Point(x_ / scalar, y_ / scalar);&#10;        }&#10;&#10;        // Equality operator&#10;        bool operator==(const Point&amp; other) const {&#10;            return x_ == other.x_ &amp;&amp; y_ == other.y_;&#10;        }&#10;&#10;        // Inequality operator&#10;        bool operator!=(const Point&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;&#10;        T x() const {&#10;            return x_;&#10;        }&#10;&#10;        T y() const {&#10;            return y_;&#10;        }&#10;&#10;&#10;        Point&amp; at_x(T new_x) {&#10;            x_ = new_x;&#10;            return *this;&#10;        }&#10;&#10;        Point&amp; at_y(T new_y) {&#10;            y_ = new_y;&#10;            return *this;&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U distance_from(const Point&lt;U&gt;&amp; other) const {&#10;            U dx = static_cast&lt;U&gt;(other.x() - static_cast&lt;U&gt;(x_));&#10;            U dy = static_cast&lt;U&gt;(other.y() - static_cast&lt;U&gt;(y_));&#10;            return static_cast&lt;U&gt;(sqrt(dx * dx + dy * dy));&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U distance_from(const Point&lt;U&gt; other) const {&#10;            U dx = static_cast&lt;U&gt;(other.x() - static_cast&lt;U&gt;(x_));&#10;            U dy = static_cast&lt;U&gt;(other.y() - static_cast&lt;U&gt;(y_));&#10;            return static_cast&lt;U&gt;(sqrt(dx * dx + dy * dy));&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U y_from(const Point&lt;U&gt;&amp; other) const {&#10;            return static_cast&lt;U&gt;(other.y() - y_);&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U y_from(const Point&lt;U&gt; other) const {&#10;            return static_cast&lt;U&gt;(other.y() - y_);&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U x_from(const Point&lt;U&gt;&amp; other) const {&#10;            return static_cast&lt;U&gt;(other.x() - x_);&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        U x_from(const Point&lt;U&gt; other) const {&#10;            return static_cast&lt;U&gt;(other.x() - x_);&#10;        }&#10;&#10;        template&lt;typename U&gt;&#10;        Point&lt;U&gt; cast() const {&#10;            return Point&lt;U&gt;(static_cast&lt;U&gt;(x_), static_cast&lt;U&gt;(y_));&#10;        }&#10;&#10;    };&#10;&#10;    namespace point {&#10;        template&lt;typename T&gt;&#10;    concept HasXPosMember = requires(T t) {&#10;            t.x;&#10;    };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasXposMethod = requires(T t) {&#10;            t.y();&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasXPos = HasXPosMember&lt;T&gt; || HasXposMethod&lt;T&gt;;&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasYPosMember = requires(T t) {&#10;            t.y;&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasYposMethod = requires(T t) {&#10;            t.y();&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasYPos = HasYPosMember&lt;T&gt; || HasYposMethod&lt;T&gt;;&#10;    }&#10;&#10;    template&lt;typename T&gt;&#10;    concept IsPoint = point::HasXPos&lt;T&gt; &amp;&amp; point::HasYPos&lt;T&gt;;&#10;&#10;} // namespace mite" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/include/modules/mite/flat/size.ixx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/include/modules/mite/flat/size.ixx" />
              <option name="originalContent" value="module;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;type_traits&gt;&#10;&#10;export module mite.size;&#10;&#10;export namespace mite {&#10;&#10;    template &lt;typename T&gt;&#10;    struct Size {&#10;    static_assert(std::is_arithmetic_v&lt;T&gt;, &quot;Point must be arithmetic type&quot;);&#10;&#10;    protected:&#10;        T height_;&#10;        T width_;&#10;&#10;    public:&#10;        explicit Size(T height = 0, T width = 0) : height_(height), width_(width) {}&#10;&#10;        Size operator+(const Size&amp; other) const {&#10;            return Point(height_ + other.height_, width_ + other.width_);&#10;        }&#10;&#10;        Size operator+(const Size other) const {&#10;            return Point(height_ + other.height_, width_ + other.width_);&#10;        }&#10;&#10;        Size operator-(const Size&amp; other) const {&#10;            return Point(height_ - other.height_, width_ - other.width_);&#10;        }&#10;&#10;        Size operator-(const Size other) const {&#10;            return Point(height_ - other.height_, width_ - other.width_);&#10;        }&#10;&#10;        Size&amp; operator+=(const Size&amp; other) {&#10;            height_ += other.height_;&#10;            width_ += other.width_;&#10;            return *this;&#10;        }&#10;&#10;        Size&amp; operator+=(const Size other) {&#10;            height_ += other.height_;&#10;            width_ += other.width_;&#10;            return *this;&#10;        }&#10;&#10;        Size&amp; operator-=(const Size&amp; other) {&#10;            height_ -= other.height_;&#10;            width_ -= other.width_;&#10;            return *this;&#10;        }&#10;&#10;        Size&amp; operator-=(const Size other) {&#10;            height_ -= other.height_;&#10;            width_ -= other.width_;&#10;            return *this;&#10;        }&#10;&#10;        Size operator*(T scalar) const {&#10;            return Point(height_ * scalar, width_ * scalar);&#10;        }&#10;&#10;        Size&amp; operator*(T&amp; scalar) {&#10;            height_ *= scalar;&#10;            width_ *= scalar;&#10;            return *this;&#10;        }&#10;&#10;        Size operator*=(T scalar) {&#10;            height_ *= scalar;&#10;            width_ *= scalar;&#10;            return *this;&#10;        }&#10;&#10;        Size operator/(T&amp; scalar) const {&#10;            if (scalar == 0) {&#10;                throw std::invalid_argument(&quot;Division by zero is not allowed.&quot;);&#10;            }&#10;            if constexpr (std::is_integral_v&lt;T&gt;) {&#10;                if (height_ % scalar != 0 || width_ % scalar != 0) {&#10;                    throw std::invalid_argument(&quot;Division results in non-integer values.&quot;);&#10;                }&#10;            }&#10;            return Point(height_ / scalar, width_ / scalar);&#10;        }&#10;&#10;        Size operator/(T scalar) const {&#10;            if (scalar == 0) {&#10;                throw std::invalid_argument(&quot;Division by zero is not allowed.&quot;);&#10;            }&#10;            if constexpr (std::is_integral_v&lt;T&gt;) {&#10;                if (height_ % scalar != 0 || width_ % scalar != 0) {&#10;                    throw std::invalid_argument(&quot;Division results in non-integer values.&quot;);&#10;                }&#10;            }&#10;            return Point(height_ / scalar, width_ / scalar);&#10;        }&#10;&#10;        Size&amp; operator/=(T scalar) {&#10;            if (scalar == 0) {&#10;                throw std::invalid_argument(&quot;Division by zero is not allowed.&quot;);&#10;            }&#10;            if constexpr (std::is_integral_v&lt;T&gt;) {&#10;                if (height_ % scalar != 0 || width_ % scalar != 0) {&#10;                    throw std::invalid_argument(&quot;Division results in non-integer values.&quot;);&#10;                }&#10;            }&#10;            if (scalar == 0) {&#10;                throw std::invalid_argument(&quot;Division by zero is not allowed.&quot;);&#10;            }&#10;            height_ /= scalar;&#10;            width_ /= scalar;&#10;            return *this;&#10;        }&#10;&#10;        Size&amp; operator/=(T&amp; scalar) {&#10;            if (scalar == 0) {&#10;                throw std::invalid_argument(&quot;Division by zero is not allowed.&quot;);&#10;            }&#10;            if constexpr (std::is_integral_v&lt;T&gt;) {&#10;                if (height_ % scalar != 0 || width_ % scalar != 0) {&#10;                    throw std::invalid_argument(&quot;Division results in non-integer values.&quot;);&#10;                }&#10;            }&#10;            height_ /= scalar;&#10;            width_ /= scalar;&#10;            return *this;&#10;        }&#10;&#10;        bool operator==(const Size&amp; other) const {&#10;            return height_ == other.height_ &amp;&amp; width_ == other.width_;&#10;        }&#10;&#10;        bool operator==(const Size other) const {&#10;            return height_ == other.height_ &amp;&amp; width_ == other.width_;&#10;        }&#10;&#10;        bool operator!=(const Size&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;&#10;        bool operator!=(const Size other) const {&#10;            return !(*this == other);&#10;        }&#10;&#10;        T height() const {&#10;            return height_;&#10;        }&#10;&#10;        T width() const {&#10;            return width_;&#10;        }&#10;&#10;        Size&amp; of_height(T new_height) {&#10;            height_ = new_height;&#10;            return *this;&#10;        }&#10;&#10;        Size&amp; of_width(T new_width) {&#10;            width_ = new_width;&#10;            return *this;&#10;        }&#10;&#10;        bool can_fit(const Size&amp; other) const {&#10;            return height_ &gt;= other.height_ &amp;&amp; width_ &gt;= other.width_;&#10;        }&#10;&#10;        bool can_fit(const Size other) const {&#10;            return height_ &gt;= other.height_ &amp;&amp; width_ &gt;= other.width_;&#10;        }&#10;&#10;        // Compare area of two points&#10;        bool operator&lt;(const Size&amp; other) const {&#10;            return (height_ * width_) &lt; (other.height_ * other.width_);&#10;        }&#10;&#10;        bool operator&lt;(const Size other) const {&#10;            return (height_ * width_) &lt; (other.height_ * other.width_);&#10;        }&#10;&#10;        bool operator&gt;(const Size&amp; other) const {&#10;            return (height_ * width_) &gt; (other.height_ * other.width_);&#10;        }&#10;&#10;        bool operator&gt;(const Size other) const {&#10;            return (height_ * width_) &gt; (other.height_ * other.width_);&#10;        }&#10;&#10;        bool operator&lt;=(const Size&amp; other) const {&#10;            return (height_ * width_) &lt;= (other.height_ * other.width_);&#10;        }&#10;&#10;        bool operator&lt;=(const Size other) const {&#10;            return (height_ * width_) &lt;= (other.height_ * other.width_);&#10;        }&#10;&#10;        bool operator&gt;=(const Size&amp; other) const {&#10;            return (height_ * width_) &gt;= (other.height_ * other.width_);&#10;        }&#10;&#10;        bool operator&gt;=(const Size other) const {&#10;            return (height_ * width_) &gt;= (other.height_ * other.width_);&#10;        } &#10;    };&#10;&#10;    namespace size {&#10;&#10;        template&lt;typename T&gt;&#10;        concept HesHeightMember = requires(T t) {&#10;            t.height;&#10;    };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasHeightMethod = requires(T t) {&#10;            t.height();&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HesHeight = HesHeightMember&lt;T&gt; || HasHeightMethod&lt;T&gt;;&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasWidthMember = requires(T t) {&#10;            t.width;&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasWidthMethod = requires(T t) {&#10;            t.width();&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasWidth = HasWidthMember&lt;T&gt; || HasWidthMethod&lt;T&gt;;&#10;&#10;    } // namespace size&#10;&#10;    template&lt;typename T&gt;&#10;        concept IsSize = size::HesHeight&lt;T&gt; &amp;&amp; size::HasWidth&lt;T&gt;;&#10;}&#10;" />
              <option name="updatedContent" value="module;&#10;#include &lt;stdexcept&gt;&#10;#include &lt;type_traits&gt;&#10;&#10;export module mite.size;&#10;&#10;export namespace mite {&#10;&#10;    template &lt;typename T&gt;&#10;    struct Size {&#10;    static_assert(std::is_arithmetic_v&lt;T&gt;, &quot;Size must be arithmetic type&quot;);&#10;&#10;    protected:&#10;        T height_;&#10;        T width_;&#10;&#10;    public:&#10;        explicit Size(T height = 0, T width = 0) : height_(height), width_(width) {}&#10;&#10;        Size operator+(const Size&amp; other) const {&#10;            return Size(height_ + other.height_, width_ + other.width_);&#10;        }&#10;&#10;        Size operator-(const Size&amp; other) const {&#10;            return Size(height_ - other.height_, width_ - other.width_);&#10;        }&#10;&#10;        Size&amp; operator+=(const Size&amp; other) {&#10;            height_ += other.height_;&#10;            width_ += other.width_;&#10;            return *this;&#10;        }&#10;&#10;        Size&amp; operator-=(const Size&amp; other) {&#10;            height_ -= other.height_;&#10;            width_ -= other.width_;&#10;            return *this;&#10;        }&#10;&#10;        Size operator*(T scalar) const {&#10;            return Size(height_ * scalar, width_ * scalar);&#10;        }&#10;&#10;        Size&amp; operator*=(T scalar) {&#10;            height_ *= scalar;&#10;            width_ *= scalar;&#10;            return *this;&#10;        }&#10;&#10;        Size operator/(T scalar) const {&#10;            if (scalar == 0) {&#10;                throw std::invalid_argument(&quot;Division by zero is not allowed.&quot;);&#10;            }&#10;            if constexpr (std::is_integral_v&lt;T&gt;) {&#10;                if (height_ % scalar != 0 || width_ % scalar != 0) {&#10;                    throw std::invalid_argument(&quot;Division results in non-integer values.&quot;);&#10;                }&#10;            }&#10;            return Size(height_ / scalar, width_ / scalar);&#10;        }&#10;&#10;        Size&amp; operator/=(T scalar) {&#10;            if (scalar == 0) {&#10;                throw std::invalid_argument(&quot;Division by zero is not allowed.&quot;);&#10;            }&#10;            if constexpr (std::is_integral_v&lt;T&gt;) {&#10;                if (height_ % scalar != 0 || width_ % scalar != 0) {&#10;                    throw std::invalid_argument(&quot;Division results in non-integer values.&quot;);&#10;                }&#10;            }&#10;            height_ /= scalar;&#10;            width_ /= scalar;&#10;            return *this;&#10;        }&#10;&#10;        bool operator==(const Size&amp; other) const {&#10;            return height_ == other.height_ &amp;&amp; width_ == other.width_;&#10;        }&#10;&#10;        bool operator!=(const Size&amp; other) const {&#10;            return !(*this == other);&#10;        }&#10;&#10;        T height() const {&#10;            return height_;&#10;        }&#10;&#10;        T width() const {&#10;            return width_;&#10;        }&#10;&#10;        Size&amp; of_height(T new_height) {&#10;            height_ = new_height;&#10;            return *this;&#10;        }&#10;&#10;        Size&amp; of_width(T new_width) {&#10;            width_ = new_width;&#10;            return *this;&#10;        }&#10;&#10;        bool can_fit(const Size&amp; other) const {&#10;            return height_ &gt;= other.height_ &amp;&amp; width_ &gt;= other.width_;&#10;        }&#10;&#10;        // Compare area of two points&#10;        bool operator&lt;(const Size&amp; other) const {&#10;            return (height_ * width_) &lt; (other.height_ * other.width_);&#10;        }&#10;        bool operator&gt;(const Size&amp; other) const {&#10;            return (height_ * width_) &gt; (other.height_ * other.width_);&#10;        }&#10;        bool operator&lt;=(const Size&amp; other) const {&#10;            return (height_ * width_) &lt;= (other.height_ * other.width_);&#10;        }&#10;        bool operator&gt;=(const Size&amp; other) const {&#10;            return (height_ * width_) &gt;= (other.height_ * other.width_);&#10;        } &#10;    };&#10;&#10;    namespace size {&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasHeightMember = requires(T t) {&#10;            t.height;&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasHeightMethod = requires(T t) {&#10;            t.height();&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasHeight = HasHeightMember&lt;T&gt; || HasHeightMethod&lt;T&gt;;&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasWidthMember = requires(T t) {&#10;            t.width;&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasWidthMethod = requires(T t) {&#10;            t.width();&#10;        };&#10;&#10;        template&lt;typename T&gt;&#10;        concept HasWidth = HasWidthMember&lt;T&gt; || HasWidthMethod&lt;T&gt;;&#10;&#10;    } // namespace size&#10;&#10;    template&lt;typename T&gt;&#10;        concept IsSize = size::HasHeight&lt;T&gt; &amp;&amp; size::HasWidth&lt;T&gt;;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>